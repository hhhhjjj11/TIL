## while문 쓸 때 주의사항

- while안에 반목문이나 조건문 쓰고 그 안에서 뭐 됐을 때 멈추고 싶으면
- 해당 반복문이나 조건문 안에서 멈추고
- 상위 단계에서 도 똑같이 멈추고
- 그렇게 최상위 단계까지 모든 단계에서 break를 걸어줘야 전부다멈춤.
- 하위 단계에서만 break를 걸면 그 윗단계는 안멈추고 계속 돌아감

## while문 쓸 때 주의사항 2

- cnt == 3 이랑
- cnt > 3 이랑
- while안에서 반복문 돌리면 반복문은 어쨌든 한 바퀴 도는게 하나의 단위 이므로
- 하위 스코프인 반복문 안에서 break걸때랑 반목문 돌고나서 상위 스코프에서 break걸때랑 멈추는 조건이 다를 수 있다는 점 유의하자.

## 이진법

```
bin()
```

</br>
</br>

## 숫자 처리할 때 : 나머지와 몫? vs 리스트?

- 나머지와 몫을 사용할 경우 -> 앞의 0은 고려하지 못함을 주의하자
- 예컨대, 10003의 경우 (1,0) 과 (0,0,3)으로 나누고 싶을때 몫과 나머지를 사용하여
  10003//1000과 10003%1000으로 나누면 10과 3임! (0,0,3)이 아니라!
- 백준1356 유진수 문제 참조.

</br>
</br>

## 리스트에서 각 항과 그 이전 항에 관한 조건을 써야할 때

- li[i-1]하면 i=0인경우 마지막항으로 넘어가기 때문에
- 첫항과 나머지를 따로 구분해서 작성해 주었음!
- SWEA어디에 단어가 들어갈 수 있을까 문제 참조.

</br>
</br>

## trunc 버림이 아니라 절사임. 말그래도 소숫점아래 일정부분을 지워버리는거임 올림버림 이런거아니라.

</br>
</br>
</br>

## 메모리와 시간 사용을 줄이기 위해서는, 빠르게 작동할 수 있도록 컴퓨터가 할 일을 줄여줘야함.!!

- 무슨얘기냐. 다음의 두가지 방법을 비교.

- 방법 1. 모든 3가지 순서쌍을 구해놓고, 필터를 통해 작은 두변의 합이
  가장큰 변 보다 큰 경우만을 남기고나서, 겹치는 것들을 하나로 세고, 최종적으로
  남은 것들의 개수를 출력.

- 방법 2. 가장 작은 변의 길이는 1~N//3+1만이 가능하므로, 해당범위만 반복하도록 하고,
  두번째로 작은 변의 길이는 [가장작은변, N//2+1에서 가장작은 변을 뺀 것]중에 큰 최대값
  부터 가능하므로, 또 그 범위만 반복하도록하고, 그렇게 첫번째 변과 두번째 변을 정하면
  세번째 변은 자동으로 유일하게 정해지므로, 세번째 변은 따로 처리하지 않고 그냥
  cnt를 세주면 된다.
