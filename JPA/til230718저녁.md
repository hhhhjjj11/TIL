비밀번호 암호화 안되면 시큐리티로 로그인 못하는듯.

컨트롤러단에서 입력받은 비밀번호를 인코딩해서 다시 넣어주고 db에저장해야함.

로그인 진행이다되면 시큐리티 세션을 만들고 거기다가 인증정보를 저장을해주는데
ㄱ그 세션이 security contextholder이고
거기에 저장하는 객체가 Authentication객체 (반드시

// Authentication 안에 User정보가 있어야됨.
User오브젝트 타입 = UserDetails타입 객체

UserDetailService

- 스프링시큐리티에서
설정파일에서 인증이나 권한이 필요한 uri를 매핑해줄수도잇고
아니면 컨트롤러에서 @Secured로 잡아줘도 됨.
(설정파일에서 @Secured어노테이션활성화하는 어노테이션@EnableGlobalMethodSecurity(securedEnabled=true) 달아줘야댐)

- @PreAuthroize는 잘 머르겟다


작성한것
1. securityConfig 설정파일
2. PrincipalDetails implements UserDetails
3. PrincipalDetailService implements UserDetailService

### IoC
- 제어의 역전, Inversion of Control
- 매소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라 외부에서 결정되는 것을 의미.
- 폭넓게 적용되어 있음.
- 일반적으로 자바프로그램은 main메서드에서 시작해서 개발자가 미리 정한 순서를 따라 객체가 생성되고 실행됨.
- 반면, 서블릿을 생각해보자. 서블릿을 개발해서 서버에 배포할 수는 있으나, 배포하고 나서는 직접 제어할 수 있는 방법은 없음.
대신 서블릿에 대한 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 객체를 만들고 그 안의 메소드를 호출함.
- 이러한 방식은 대부분의 프레임워크에서 사용하는 방식임. 
- 정해진 흐름 안에서 개발자는 적절한 코드부품을 끼워넣는 방식으로 개발하게 됨.
- 이렇게 조립된 코드의 최종 호출은 개발자에 의해서 제어되는 것이 아니라, 프레임워크 내부에서 결정된 대로 이뤄지게 되는데,
이러한 현상을 "제어의 역전"이라고 표현함.


### IoC컨테이너
-  위에서 말한 제어의 역전. 즉, 개발자가 정한 것이 아니라 프레임워크에서 이미 정해진 호출시점에 인스턴스 생성부터 소멸까지를 
관리하는 컨테이너를 말함.


### 비즈니스 로직
- 비즈니스 로직(Business logic)은 컴퓨터 프로그램에서 실세계의 규칙에 따라 데이터를 생성·표시·저장·변경하는 부분을 일컫는다. 
이 용어는 특히 데이터베이스, 표시장치 등 프로그램의 다른 부분과 대조되는 개념으로 쓰인다.
- 비즈니스 로직과 대조되는 개념은 주로 기술적인 부분을 가리키며, 시스템의 구현, 데이터 처리, 네트워크 통신 등과 관련된 요소들을 의미


### 구글로그인
1. 구글개발자페이지에서 뭐 작업하고
2. OAuth-client 디펜던시 추가
3. yml에 설정추가..
```
security:
 oauth2:
    client:
      registration:
        google:
          client-id: 발급받은거넣어주기
          client-secret: 넣어주기~

```
4. SecurityConfig에설정추가
```
.and()
.oauth2Login()
.loginPage("/loginForm");
```
=====여기까지하면 일단 클라이언트에서 구글로그인해서 구글서버로부터 accesstoken 넘겨받음 ====
- 이제 우리 서버에서 후처리 해줘야댐.
- 구글서버로부터 받은 토큰 + 프로필가지고 뭐 할거해줘야함. 예를들면 어세스토큰이랑 리프레시토큰 발급해주거나..


1. PrincipalOauth2UserService extends DefaultOAuth2UserService 클래스의
loadUser메서드를통해 후처리한다...


- Authentication객체의 안에는 UserDetails또는 OAuth2User(OAuth를사용하는경우)가 들어갈 수 있다.
일반로그인할경우 UserDetails / 소셜로그인할경우 OAuth2User


1. 시큐리티세션에는 Authentication객체만 저장가능하다. (그렇게 되어잇다.)
2. Authentication객체에는 사용자에관한정보(?)가 들어갈 수있는데 두가지 타입이 가능하다.
-> OAuth2User / UserDetails(PrincipalDetails)
3. 이때 위의 두 클래스는 인터페이스이고, 유저정보도 없기때문에, 이를 구현한 클래스를 만들것이며, 
그 안에는 회원정보도 들어가도록 한다. (PrincipalDetails)
4. 이렇게 해주면 이제 PrincipalDetails 는 유저객체를 갖고있으므로 세션정보로부터 유저객체에접근가능하다.

5. 그런데 OAuth / UserDetail 로그인 여부에 따라 달라져서 복잡하니까 어떻게하냐면
6. OAuth2User도 PrincipalDetails에 묶어버린다.
7. 그러면 걍 Authentication객체에 들어가는 사용자정보 타입을 PrincipalDetails로 통일시킬수있다.


- 서비스에서... 후처리하고 PrincipalDetails 데이터를 반환해주면 된다!!!!!!!!

- 서비스를 따로 안만들어도 load어쩌구 메서드는 발동이됨 
서비스를 따로 만드는 이유는 principalDetails 타입을 반환하기 위해서임!!
만약에 걍 OAuth2User 이나 UserDetails 타입만 반환해도 되면 걍 오버라이딩 안해도됨!!!!
하지만 우리가 한거는 둘이 합쳐서 PrincipalDetails로 묶어서 반환하고싶은거니까 다시쓴거임
+ 또 , 후처리를 로직을 작성하기위해서 오버라이딩 한것이기도 함! 