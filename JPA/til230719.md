### spring.jpa.hibernate.naming.physical-strategy
- 엔티티에작성한 컬럼명을 그대로 db에 반영 (언더스코어형태로 전환X)


### 강의내용
1. 


### 테스트
1. authentication code 가지고 카카오서버로부터 accesstoken 받기


### oauth2 의 authorization code grant type
- 인증 및 권한 부여를 위해 사용자의 리소스에 대한 접근 권한을 요청하는 과정의 일종
- 어떤방식으로 인증 및 권한 부여를 하는지를 나타내는 개념.


시큐리티를 이용한다.

1. 클라이언트에서 -> 카카오서버로 요청날려서 로그인해서 인증코드 받아오고..
<서버> 2. 인증코드가 담긴 요청을 서버로 날리면 서버에서 받아서 후처리..



## 시큐리티
- 로그인 로그아웃 이미 구현되어있음.

1. SecurityConfig 설정을해서 권한 요청과 제한을 매핑해주면 해당 URI접근시 403에러.

- 회원가입로직은 생략하고 진행해보자

- BCryptPasswordEncoder 로직을 블로그에서는 application main메서드에서 했고 강의에서는
SecuritiConfig 에서 처리함.

- 파라미터 username 맞춰줘야함. 만약에 다르게할거면 설정파일에서 설정따로 해줘야댐.
- /login이 발동이 되면 IoC컨테이너에서 UserDetailService로 등록되어있는 서비스를 찾음.
(우리는 PrincipalDetailService로 구현했었다)
(formLogin() 으로 설정한 경우 -> UserDetailService)
(oauth2Login()으로 설정한 경우 -> DefaultOAuth2UserService 로 등록되어있는 서비스를 찾음!!)
- 그리고 찾으면 바로 loadUserByUsername 메서드를 호출함.
- 그러면 loadUserByUsername 메서드는 인자로 받은 username 파라미터를 가지고 
   userRepository를 불러서 해당 이름으로 유저가 있는지를 판별함. <- 이 부분을 메서드 본문에 작성해줘야함.

- 근데 OAuth의 경우에는
     - loadUser메서드는 후처리로직인듯
     - 그래서 loadUser메서드의 인자로 들어가는 요청객체는 구글서버로부터 받은 것임(access토큰 + 


- 시큐리티 개꿀기능 -> 인증필요한 페이지에서 로그인 화면으로 넘어간 경우 , 로그인 성공시 직전페이지로 알아서 리다이렉트 됨. 개꿀



- 시큐리티 컨피겨에서
    -> 어떤 로그인의 경우 어떤 서비스 로직이 매핑될것인지 서비스를 매핑해줌.

