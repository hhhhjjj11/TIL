## 2월 21일 화

### 1. 큐

### 2. 큐 연산

- 뒤로 삽입하는거
- 앞으로 빼내고 반환하는거

 </br>

### 2-1. 큐 연산 (쩌리)

- 큐 생성해주기 단순히 리스트만 생성하는게 아님,
  - 큐 사이즈, rear/front 값 초기설정 등 해준다.
- 큐가 포화상태인지 체크하는거
  </br>

### 2-2. 큐연산구현 : 삽입

1. rear값 1 증가시킴
2. Q[rear] = item

\*_핵심: 막항인덱스(rear) 1증가시키고 할당_

</br>

### 2-3. 큐연산구현 : 삭제

_핵심 : front 오른쪽한칸 이동시키고 그놈 반환, 반환하고 front를 한칸 이동시키지 않음. 그렇기 때문에 다음번 삭제시 오른쪽으로 한칸 이동한다음 반환해야하는 것임_

1. fornt 값 1증가시키고
2. Q[front] 리턴

</br>

\*_헷갈리는 이유 :</br>
직관 = 원래첫번째꺼 반환하고 (삭제하고) 첫인덱스가 1커지는 것이 직관적으로 자연스러움</br>
로직 = 첫인덱스 1증가시키고 그 놈을 반환함. (??)_

_\*\*어차피 front 는 deQueue() 연산할 때만 씀, 결과는 똑같음. 직관과는 조금 달라도 저렇게 하는 편이 enQueue()랑 인덱스를 먼저 움직인 다는점에서 통일성을 가질 수 있어서 저렇게 쓰는듯_
</br>

_\*\*공백상태와 포화상태의 구분을 쉽게하기 위해 front를 비워두기 위해. 그렇게 한다고함.
무슨얘기냐,, 삭제하고 front한칸 오른쪽으로 옮겨놓으면 rear + 2 = front ㅇ_

</br>

### 2-4. 큐연산구현 : 큐생성

1. 크기가 n인 1차원 배열 생성
2. front 랑 rear를 -1로 초기화

### 3. 들어야하는 의문: "선형 큐의 문제점"

-> rear랑 front가 오른쪽으로만 한칸씩 이동하고, 큐의 크기가 정해져있으면, 아무리 앞으로 빼내도 뒤로 못집어넣는거 아닌가?
-> 맞음.ㅇㅇ -> 이것이 바로 선형큐 이용시의 문제점임

### 4. 어떤해결방법이 있을까?

1. 방안1: 매 연산마다 원소들을 한칸씩 다 옮김 ㅋ
2. 방안2: 원형큐의 논리적 구조를 채용!
   - 원형큐처럼, rear랑 front가 오른쪽으로 한칸씩 움직이는데 넘어가면 다시 처음으로 넘어오도록 생각

### 원형큐

### 원형큐의 핵심:

- front랑 rear가 똑같이 한칸씩 오른쪽으로 움직이는데, n-1 다음에는 0으로 이동해야함.
- 나머지연산자 쓰면 끝. 어려울거 없음 ㅋ

### 원형큐에서 공백상태와 포화상태 검사하기

1. 공백상태 : front == rear
2. 포화상태 : 삽입할 rear다음위치 = 현재 front

   ```py
   def isEmpty():
       return front == rear

   def isFull():
       return (rear+1) % len(cQ) == front
   ```
