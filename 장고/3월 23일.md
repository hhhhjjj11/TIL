# 3월 23일


# 회원가입기능구현

1. url만들고
2. views.에서
- 회원가입전용 빌트인 폼 임포트해서쓰면되는데...! 그전에 알아야 할 것이 있다.

- 알아두기
모델폼은 참고하는 모델스키마를 오버라이딩해서 써야했음을 기억하자(이때 메타클래스를 이용햇었다.)
빌트인모델폼인 UserCreationForm 은 기본적으로 auth.User모델(장고기본유저스키마)을 참조하고 있다. 따라서 내가 유저스키마를 새로 커스터마이징 했다면 UserCreationForm이 참조하는 모델을 오버라이딩해주어야 한다. 그렇지 않으면 에러가난다.
즉, forms.py에서 메타클래스를 통해 오버라이딩 해줘야한다.

- 이때 forms.py에 user모델을 import하는 방법이 특별함 , User모델은 특별한 모델이기때문에 장고에서 특수취급함, 불러오는 전용 메서드가 있음. 이 메서드를 이용해서 접근하는 것이 좋음. 수정시 일일이 코드고치지않아도되는 등.

```python
from django.contrib.auth.forms import UserCreationForm
# 유저모델 불러오는 전용 메서드 임포트.
from django.contrib.auth import get_user_model

class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        # 메타클래스 인자로 UerCreationForm.Meta를 넣어줘야 나머지는 그대로이고 model만 오버라이딩 됨. 저거 넣지 않으면 아예 전체를 새로 정의하는 것임.
        model = get_user_model()
```

- 자 이제 veiws에서 다음과 같이 써주면 된다.
```python
from django.http import HttpResponse
## 회원가입 빌트인 폼
from django.contrib.auth.forms import UserCreationForm
from .forms import CustomUserCreationForm


def signup(req):
    if req.method == 'POST':
        form = CustomUserCreationForm(req.POST)
        print(form.data)
        if form.is_valid():
            user = form.save()
            # 회원가입 한다음에 로그인처리까지.
            # 로그인시 로직과 다르게, 여기서 쓰는 모델폼은 get_user()메서드를 갖고있지 않기 때문에 쓰면 오류나고, form.save()의 반환값을 user로 받은 다음에 두번째 인자로 넣어줘야 한다.
            auth_login(req, user)
            return redirect('app1:index')
    else:
        form = CustomUserCreationForm()
    context = {
        'form':form
    }
    return render(req, 'accounts/signup.html', context)
```

- 커스텀안하고 써도 되는것 같긴한데 뭔말인지 놓침




# 로그인된 유저만 접근가능하도록 접근제한걸기

두가지 방법이 잇다

방법 1 : 템플릿에서 user.is_authenticated 이용
템플릿에서

```html
    {% if user.is_authenticated %}
    <a href="{% url 'accounts:logout' %}">로그아웃</a>
    <a href="{% url 'accounts:update' %}">회원정보수정</a>
    <form action="{% url 'accounts:delete' %}" method="POST">
        {% csrf_token %}
        <input type="submit" value="탈퇴하기">
    </form>
    <h1>Hello, {{ user }}</h1>
    {% else %}
    <a href="{% url 'accounts:signup' %}">회원가입</a>
    <a href="{% url 'accounts:login' %}">로그인</a>
    {% endif %}
<hr>
    {% block content %}{% endblock content %}
```
- 이렇게 템플릿에서만 제한을 걸면 문제가 생길 여지가 남아잇음.
- 주소창에 url을 입력해서 요청을 걸면 못막음
- 그래서 미들웨어에서도 해줘야 됨

방법2: 미들웨어에서 req.user.is_authentiated 이 용
views.py에서
```python
def login(req):
    if req.user.is_authenticated:
        return redirect('articles:index')
```
- 유저가 로그인상태라면 이하 로직 실행 하지말구 다시 메인으로 리다이렉트.




# 데코레이터
- 기존에 작성된 함수는 그냥 두고 기능을 추가 하고 싶을 때

사용방법
```
@hell
def bye():
    pirnt('byebye')
```


데코레이터를 이용한 라우팅 분기
require_POST() : post요청
require_safe() : get요청 #디비건드는게아니라서 안전하다는 의미로 safe로 표기함

사용방법 : 걍 모듈 불러와서 써주면 끝;

views.py에서
```
from django.views.decorators.http import require_POST, require_safe, require_http_methods

@require_http_methods(['POST'])
def delete(req):
    user = req.user
    user.delete()
    auth_logout(req)
    return redirect('app1:index')
```
-> 이러면 delete미들웨어는 포스트요청시에만 작동하게 됨.

get으로 요청들어가면 405에러가 뜸.
참고. 405 : 요청방법이 서버에 전달 되었으나 사용 불가능한 상태를의미
2XX -> 정상, 성공
4XX -> 클라이언트잘못,(요청이 이상함)
5XX -> 서버잘못 (서버가 이상)

- 다음도 기능이 똑같다.

```python
@require_POST
def delete(req):
    user = req.user
    user.delete()
    auth_logout(req)
    return redirect('app1:index')

```
- 사실 @require_http_methods()로 다 해결긴하는데, 코드 가독성이 이게 더 좋기때문에 혼용함. (http_methods()만써도 상관은 없어요)


참고. require_GET이 있지만 장고에서는 require_safe를 사용하는 것이 더 좋습니다. 의미적으로
- require_GET은 말그대로 GET만 허용함
- require_safe 는 GET과 HEAD허용
      - HEAD는 HTTP Body부분(HTML아님)을 제외한 HEAD 부분만 반환 해주는 함수로, GET보다 빠름
- 본문 내용이 없는데 HEAD를 왜 쓰나요?
       -> CONTENT 길이 등을 파악할 때 사용.. 대충 쓰임이 더 넓은듯..


데코레이터를 이용해서 로그인권한있는경우에만 처리하도록 제한하기
- 알고만 있자. 데코레이터끼리 꼬여버리면 손대기 어려워서, 데코레이터는 보통 http메소드 분기용으로 쓰고, 로그인 권한 제한은 함수 본문에서 if req.user.is_authenticated: 이용해서 잡아줌.
- views.py에서
```python
from django.contrib.auth.decorators import login_required

@login_required
def delete(req):
~~~
```





# 회원정보수정(User Update)

1. 템플릿만들고
2. 미들웨어에서
```python
def update(req):
    if req.method=='POST':
        pass
    else:
        # 인자를 넣어줘야 기존 정보가 뜸.
        form = CustomUserChangeForm(instance = req.user)
        context = {
            'form':form
        }
        return render(req, 'accounts/update.html', context)

```

3. 이때 이렇게 하면 온갖 필드들이 클라이언트페이지에 다 뜸. 그래서 forms.py에서 필드를 좀 수정해주자.

```python
from django.contrib.auth.forms import UserCreationForm, UserChangeForm
# 유저모델 불러오는 전용 메서드 임포트.
from django.contrib.auth import get_user_model


class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        # 메타클래스 인자로 UerCreationForm.Meta를 넣어줘야 나머지는 그대로이고 model만 오버라이딩 됨. 저거 넣지 않으면 아예 전체를 새로 정의하는 것임.
        model = get_user_model()

# 수정전용 모델폼 UserChangeForm이 따로 있음 주의
class CustomUserChangeForm(UserChangeForm):
    class Meta(UserChangeForm.Meta):
        # 메타클래스 인자로 UerCreationForm.Meta를 넣어줘야 나머지는 그대로이고 model만 오버라이딩 됨. 저거 넣지 않으면 아예 전체를 새로 정의하는 것임.
        model = get_user_model()
        fields= ('username', 'email','first_name','last_name')
        # 필드에 지정한 필드들만 뜨게 됨.
```

# 비밀번호변경 기능구현

이것도 걍 모델폼PasswordChangeForm 제공해줌 import해서 써주면 됨.

- 근데, 비밀번호 변경하면 세션끊겨셔(?) 로그인 풀림, 그래서 다시 업데이트해서 로그인 상태를 유지해줘야함. 이때 걍 개꿀모듈 불러다 써주면 됨.

```python
from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm
from django.contrib.auth import update_session_auth_hash



def change_password(req):
    if req.method == 'POST':
        form = PasswordChangeForm(req.user, req.POST)
        if form.is_valid():
            form.save()
            # 비밀번호면경하면 세션 끊겨서 로그아웃됨, 그래서 다시 업데이터해서 로그인상태 유지해줘야함. 이때 걍 개꿀모듈 또 쓰면 됨.
            update_session_auth_hash(req, form.user)
            return redirect('app1:index')
    else:
        form = PasswordChangeForm(req.user)
    context ={
        'form': form
    }

    return render(req, 'accounts/change_password.html', context)

```

참고. 모듈 모델 폼 불러다가 쓸때는 눌러보고 인자로 뭐 받는지 그때그때 확인해가면서 써주면 됩니다. 인자로 뭐들어가는지 외우는거 아닙니다.



# 회원탈퇴 구현

흐름.
- 요청들어오면 해당유저 찾아서 지우고 리다이렉트 하면 그만.
- 요청들어온 유저를 어떻게찾을까? -> 존나쉽게 찾을 수 있도록 되어있다.
걍 user = req.user 하면 끝
(원래는 요청에서 쿠키까서 세션 뒤져서 찾아야하는데 장고가 내부적으로 다 해준다이거임)


- 주의. 회원탈퇴로직은 db에서 회원정보데이터를 지우는것임. 로그인상태에서 회원탈퇴를 하기때문에 이경우 세션이 지워지지 않음. 그래서 세션을 지워주는 로직을 따로 넣어 주어야 함!!!
- 이때 탈퇴 먼저하고 세션을 지워줘야한다.
왜냐하면 탈퇴먼저하면 회원정보가 지워지기 때문에 세션을 못건드린다는듯.

```python
def delete(req):
    user = req.user
    user.delete()
    auth_logout(req)
    return redirect('app1:index')
```



# next에 다음 경로 담아놓고 활용하기

# [1] 로그인안된채로 글썻을때 -> 로그인페이지로 이동하고 -> 로그인하면 다시 글생성페이지로 가게 하는방법

## 방법1. 인풋태그에 저장해놓기

순서
글작성 눌렀을시에 로그인 안돼있으면 로그인화면가기
```python
def create(request):
    # 로그인되지 않은 사용자는 로그인 페이지로 리다이렉션
    # 이때 로그인 한다음에 다시 글작성 페이지로 돌아오기 위해서 쿼리스트링을 이용.
    if not request.user.is_authenticated:
        return redirect(f'/accounts/login?next={request.path}')
    else:
        return render(request, 'app1/create.html')
```
-> 이러면 /accounts/login로 get요청 가긴 가는데 쿼리스트링인 next={request.path}가 담겨서 감.



## 방법2. 자기자신으로 포스트 요청보내서 써먹기

배경지식.
어쩌구저쩌구/?next=/어쩌구/저쩌구/
로 POST 요청 보내면
쿼리스트링 이하는 request.GET에 담겨서 요청을보내준다.
즉 하나의 요청인데 req.GET도 있고 req.POST도 있다 이말임.

템플릿에서 폼태그 action 비워놓으면 눌렀을때 요청이 자기주소로 감


참고. 이때 url적을때 namespace사용 하고싶을 때: reverse모듈이용
views.py에서

```python
from django.urls import reverse

def create(request):
    # 로그인되지 않은 사용자는 로그인 페이지로 리다이렉션
    # 이때 로그인 한다음에 다시 글작성 페이지로 돌아오기 위해서 쿼리스트링을 이용.
    if not request.user.is_authenticated:
        # reverse: 전달받은 Name 에 매칭된 url을 문자열로 반환
        # return redirect(reverse('))
        print(reverse('accounts:login'))
        return redirect(reverse('accounts:login'+ f'?next={request.path}'))
        # return redirect(f'/accounts/login?next={request.path}')
    else:
        return render(request, 'app1/create.html')
```



# [2] 로그인 안된채로 삭제하면 -> 로그인 창먼저갔다가 -> 로그인되면 다시 상세페이지로

```python
def delete(req, pk):
    # 로그인 안된채로 삭제하면 -> 로그인 창먼저갔다가 -> 로그인되면 다시 상세페이지로
    if not req.user.is_authenticated:
        return redirect(reverse('accounts:login') + f'?next=/app1/detail/{pk}')
    article = Article.objects.get(pk=pk)
    article.delete()
    return redirect('articles:index')
```


# 그외


## 템플릿에서 경로 적을때 좀 가독성 좋게 하기
{% url  %} 대체품
