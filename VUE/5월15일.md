# DRF Auth System
## Authentication , Authorization
1. Authentication : 인증 (로그인ㄱㄱ)
2. Authorization : 권한 (로그인되어있는가?)
## Authentication 
- 프레임워크마다 다양한 인증방법이 있다.
- 우리가 사용할 방법 : TokenAuthentication
(DRF가 기본으로 제공)
- 참고. 모든 상황에 대한 인증 방식을 정의 하는 것이므로, 각 요청에 따라 다른 인증 방식을 거치고자 한다면 다른 방식이 필요 -> 데코레이터 활용

## TokenAuthentication 사용해보기
1. INSTALLED_APPS에 'rest_frame.authtoken' 등록
2. settings.py에 다음 코드 추가
    ```python
    REST_FRAMEWORK = {
        # Authentication
        'DEFAULT_AUTHENTICATION_CLASSES': [
            'rest_framework.authentication.TokenAuthentication',
        ],
    }
    ```
3. $ pip install dj-rest-auth
   ```
   $ pip install dj-rest-auth
   ```
4. INSTALLED_APPS에 'dj_rest_auth'추가
5. urls.py에
    ```python
    path('accounts/', include('dj_rest_auth.urls')),
    ```
6. db날리고 마이그레이션 초기화 한 후 다시 마이그레이션 하고 서버 키기 
[여기까지하면, 회원가입 추가가 안되어있어서 회원가입까지 추가하려면 다음 진행]
1. $ pip install 'dj-rest-auth[with_social]'
2. INSTALLED_APPS에 추가
    ```
        'django.contrib.sites',
        'allauth',
        'allauth.account',
        'allauth.socialaccount',
        'dj_rest_auth.registration',
    ```
3. settings.py에 다음 코드 추가
    ```python
    REST_AUTH={ # 회원가입시 토큰 발급
        'SESSION_LOGIN': False,
    }

    SITE_ID = 1
    # 하나의 컨텐츠로 여러 개의 도메인에 등록하고 싶을 때 사용
    ```
4. ulr.py에 추가
    ```python
    path('accounts/signup/', include('dj_rest_auth.registration.urls'))
    ```
5.  설정이 바꼈으므로 python manage.py migrate 다시 해주기 (뭔설정이바꼇단거지)
6.  서버켜보면 이제 /accounts/signup이 생겨있음
7.  가서 회원가입진행하면 key(통행증)를 줌 , 이것을 메모해두자
8.  이제 비밀번호를 변경해보자 
9.  포스트맨이용 ㄱㄱ
10. `http://127.0.0.1:8000/accounts/password/change/` 로 POST요청
11. [주의] new_password1, new_password2 는 body에, Authorization는 Headers에 넣는다.
12. Body,
{
 new_password1 : 새비번
  new_password2:  새비번
}
1.  Headers
{
 Authorization : Token 회원가입하고받은토큰
}
- 이때 주의, Token쓰고 한칸띈 다음에 넣어줘야함!!!!

<br><br>

# 권한해보자
1. settings.py에 코드추가
    ```python
    REST_FRAMEWORK = {
        'DEFAULT_PERMISSION_CLASSES': [
            # 'rest_framework.permissions.IsAuthenticated',
            'rest_framework.permissions.AllowAny',
        ],
    }
    ```
2. view에서 데코레이터 import
    ```python
    from rest_framework.decorators import permission_classes
    from rest_framework.permissions import IsAuthenticated
    ```
3. 로그인이 필요한 함수에 데코레이터추가
    ```python
    @api_view(['GET', 'POST'])
    @permission_classes([IsAuthenticated])
    def article_list(request):
        if request.method == 'GET':
            # articles = Article.objects.all()
            articles = get_list_or_404(Article)
            serializer = ArticleListSerializer(articles, many=True)
            return Response(serializer.data)

        elif request.method == 'POST':
            serializer = ArticleSerializer(data=request.data)
            if serializer.is_valid(raise_exception=True):
                serializer.save()
                # serializer.save(user=request.user)
                return Response(serializer.data, status=status.HTTP_201_CREATED)

    ```
4. 포스트맨으로 테스트해보자
5. POST, http://127.0.0.1:8000/api/v1/articles/
6. 로그인이 필요하도록 설정해놨으므로,
Body 에 title, content를 넣어도
 Headers에 Authorization을 넣지 않으면 에러가남. Authorization을 써주면 제대로 등록됨.

<br><br>

## 정리 
1. 인증 방법 설정
   - DEFAULT_AUTHENTICATION_CLASSES
2. 권한 설정하기
   - DEFAULT_PERMISSION_CLASSES
3. 인증방법, 권한 세부 설정도 가능
   - @authentication_classes
   - @permission_classes
4. 인증방법은 다양한 방법이 있으므로 내 서비스에 적합한 방식을 선택한다.

