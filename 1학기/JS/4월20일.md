# 3일차

- HTML 코드를 Live Server 로 켜면 무슨 원리로 화면을 눈으로 볼 수 있을까?
- 화면을 조작하는 자바스크립트 코드는 무슨 원리로 실행되고, 어떻게 화면을 변경할까?

## 1. DOM 이란?

- test.html 을 화면을 출력하기 전(렌더링 전)에 `변환 + 해석` 하는 과정이 추가된다.
- 이 때, DOM 이라는 것이 사용됨
- DOM(Document Object Model)
  - 웹 페이지의 문서 구조를 표현하는 객체 모델
  - 하는 역할
    1. HTML 문서를 트리 형태의 객체 모델로 변환
    2. Javascript 가 문서 내용을 조작할 수 있도록 도와주는 일종의 API
  - DOM 은 웹 페이지 컨텐츠(요소, 속성, 스타일)에 대한 프로그래밍 인터페이스를 제공하며, 웹 페이지의 구조나 내용을 동적으로 변경하는 데 사용

## 2. 브라우저의 렌더링 과정

1. 사용자가 웹 사이트에 접속한다 (해당 페이지(html, css)를 서버로 부터 받음)
2. 파싱(Parsing)
   - 두 가지 파서(Parser)가 일을 함
   - HTML 파서
     - 문서 내 모든 요소(element)를 나타내는 DOM 트리를 만든다.
       - `<link>` 태그와 `<style>` 태그를 찾아 CSS 파서로 전달한다.
       - 자바스크립트 부분을 호출하는 요소를 만나거나 `<script>` 태그를 만나면 자바스크립트 해석기로 전달한다.
       - 해석기가 결과를 반환하는 걸 기다리지 않는다.
   - CSS 파서
     - 문서 내 모든 스타일(style) 규칙을 나타내는 CSSOM(CSS Object Model) 트리를 만든다.
  -> html, css 파일 = 트리 구조로 변환, 자바스크립트 코드가 조작할 수 있는 상태가 됨
3. 렌더 트리(Render Tree) 생성
   - 렌더링 엔진이 위 과정에서 생성된 두 트리를 결합하여 렌더 트리를 만든다.
   - 렌더 트리는 브라우저에서 실제로 표시되는 요소들만을 포함
     - 요소의 크기, 위치, 색상 등을 계산한다.
   - 자바스크립트 코드가 요소나 스타일을 변경한다면, 변경된 부분에 대해서 렌더 트리를 다시 만든다.
4. 렌더링 엔진이 만들어진 렌더 트리를 활용하여 요소를 화면에 그린다.
  - 렌더링 과정은 크게 layout(배치), paint(그리기) 단계로 나뉜다.
  - layout: 각 요소의 크기와 위치 등을 계산
  - paint: 계산된 값을 이용하여 각 요소를 화면 상의 픽셀로 변환(필요 시 레이어를 만든다)
    - Layer: 그려지는 층. 독립적인 여러 레이어를 합쳐서 최종적인 화면을 만든다.
5. 마지막 합성(composite) 단계
  - 배치와 그리기 단계에서 생성된 레이어들을 결합하여 브라우저 화면에 표시한다.

- 이거 왜 알아야 할까 ?
  - 화면이 느리게 뜬다 -> 위 내용을 알아야 상세한 분석이 가능하다
  - 실제로 눈으로 확인하는 방법(크롬 개발자 도구 Performance 탭)


## 3. 자바스크립트 엔진

- 자바스크립트 엔진(해석기)의 주요 구성 요소
  - 코드 영역(Code segment)
    - 실행 가능한 코드, 함수 본문 등이 저장되는 메모리 영역
    - 한 줄 한 줄 내려가면서 해석 및 실행
  - 힙 메모리(Heap Memory)
    - 메모리 할당이 일어나는 곳
    - 변수 선언, 함수 저장 및 호출 등의 작업이 발생되는 영역
    - 변수나 함수가 어딘가에는 저장되어 있어야 참조나 호출을 할텐데, 그 영역이 힙 메모리
  - 콜 스택(Call Stack)
    - 호출 스택이 쌓이는 곳
    - 코드를 읽어내려가며 수행할 작업들을 밑에서부터 쌓는다.
      - 힙 메모리에서 작업 수행에 필요한 것들을 찾아서 작업을 수행하는 공간
  - 실행 컨텍스트(Execution Context)
    - 함수를 실행하기 위해서 필요한 정보
      - 변수들에 대한 정보, 매개변수에 대한 정보, 함수가 호출되는 스코프에 대한 정보(렉시컬 스코프)
    - 실행 컨텍스트가 콜 스택에 쌓였다가 실행되면서 콜 스택에서 삭제
      - 쌓여 있다가 순서가 되면 변수에 값을 할당하고 함수가 호출되고 실행 -> 후에 콜 스택에서 삭제

## 4. 자바스크립트 런타임

- 자바스크립트 엔진과 런타임은 다르다!

- 런타임: 자바스크립트 코드를 실행하는 환경
  - 엔진을 포함한 내장 라이브러리 등 추가적인 정보를 가지고 있음
  - 런타임 종류: Node.js, 크롬 브라우저 등
- 런타임엔 아래와 같은 기능들이 포함되어 있다
  - Web APIs
    - DOM API: 자바스크립트 코드로 화면을 바꿔주는 API
    - Timeout: setTimeout 등 비동기 처리를 해주는 API
      - 동기: 순차적으로 실행 + 결과를 받음
      - 비동기: 결과를 보는 순서가 보장되지 않음
      - 비동기 처리가 끝나서 콜 스택으로 다시 보내야할 경우 Callback Queue 로 해당 함수를 보냄
    - 이벤트 핸들러 등록
  - Callback Queue
    - 비동기 처리를 위한 콜백 함수들이 콜 스택에 쌓이기 전 대기하는 대기열(queue)
    - 원래 자바스크립트는 한 번에 하나의 일만 수행가능 하도록 설계(싱글 쓰레드 기반으로 설계)
      - Callback Queue 를 사용해서 마치 한 번에 여러 작업을 동시에 하는 것처럼 보이게 함
  - Event Loop
    - 콜백 함수들을 관리하여, Callback Queue 에 저장된 함수들을 콜 스택으로 넘겨주는 역할
      - [참고] 콜 스택이 비어있을 때만 Queue 에서 콜 스택으로 전달

  - 왜 이렇게 구현해놨을까?
    - 자바스크립트가 싱글 쓰레드 기반으로 구현되어 있기 때문
    - 프로세스와 쓰레드의 개념에 대해 공부해보기
      - 신입 직무 면접에 자주 나오는 질문
        - 쓰레드의 개념에 대해서 아니?
        - 멀티 쓰레드 구현해봤니?
        - 멀티 쓰레드 사용 시 문제점 및 문제점을 해결하는 방법에 대해 설명해봐(mutex & semaphore)


## 5. DOM 조작 기초 실습

- `document`: DOM 에 접근하기 위한 최상위 객체
- 데일리실습 3-1 코드를 기반으로 실습 시작

### 1. 선택자 알아보기

- 선택자
  - 자바스크립트 코드에서 HTML 요소를 선택하는 방법
  - `querySelector`: 특성 요소를 선택. CSS 선택자와 동일하게 사용함
  - `querySelectorAll`: 조건에 만족하는 모든 요소를 선택. 유사 배열 객체가 반환된다.
  - 예전 방식
    - `getElementById`: id 를 기반으로 요소 탐색
    - `getElementsByClassName`: class 를 지정한 모든 요소 반환. 유사 배열 객체가 반환된다.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<body>
  <!-- 실습 3-1 코드 기반으로 시작 -->
  <button class="btn btn-primary mt-2 ms-2">
    마우스를 올려보세요
  </button>

  <button class="btn btn-primary mt-2 ms-2">
    이곳에도 마우스를 올려보세요
  </button>
  
  <script>
    // document: DOM 에 접근하기 위한 최상위 객체
    // 요소 선택자
    // querySelector: 선택자로 요소를 선택
    // 가장 먼저 조건에 만족하는 요소를 선택
    const btn = document.querySelector('button')

    // querySelectorAll: 조건에 만족하는 모든 요소
    //   유사배열객체가 반환
    const btns = document.querySelectorAll('button')    
    console.log(btns)
    console.log(Array.isArray([1, 2, 3]))
    console.log(Array.isArray(btns))

    // getElementBy: 요소를 선택하는 옛날 버전
    // 여러가지 제약사항들이 존재한다
    // 예시) my-button id 가 2개 이상이면
    //      getElementById 는 버그남
    // 두 코드는 동일한 기능
    var btn2 = document.getElementById('my-button')
    var btn2 = document.querySelector('#my-button')

    // 두 코드는 동일한 기능
    var btn3 = document.getElementsByClassName('btn')
    var btn3 = document.querySelectorAll('.btn')
  </script>
</body>
</html>
```

- 배열(Array)
  - 관련있는 데이터들을 하나의 변수에 할당해서 관리하기 위해 사용하는 데이터 타입
  - 자바스크립트에서는 명시적 타입이 없기 때문에, 하나의 배열은 여러 자료형을 가질 수 있음
  - Array Helper Methods 등이 내장됨

- 유사배열객체(Array-Like Object)
  - 인덱스와 length 속성을 가진 객체는 일반적으로 유사배열객체로 간주한다.
  ```javascript
  const obj = {
    0: "apple",
    1: "banana",
    2: "cherry",
    length: 3
  };
  ```
  - 사용 이유
    - 배열보다 메모리가 효율적으로 관리됨
    - 배열의 동작을 제한하거나, 배열에 없는 동작을 추가하는 등의 커스터마이징 가능
    - 객체를 배열처럼 인덱스로 접근할 수 있음
  - 주의사항
    - forEach, map 등의 배열 메서드 사용 못함
    - 사용하려면 배열로 변환 후 사용

### 2. 이벤트 등록하기

    // 이벤트: 버튼 클릭 등의 사용자 동작
    // 이벤트 핸들러: 사용자가 특정 동작을 하면
    //      자동으로 등록된 함수를 실행

- 이벤트: 버튼 클릭 등 사용자의 동작
- 이벤트 핸들러: 사용자가 특정 동작을 하면 자동으로 등록된 함수를 실행해 줌
- `addEventListener`: HTML 요소에 이벤트 함수를 등록하는 이벤트 핸들러를 생성

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<body>
  <!-- 실습 3-1 코드 기반으로 시작 -->
  <button class="btn btn-primary mt-2 ms-2">
    마우스를 올려보세요
  </button>

  <button class="btn btn-primary mt-2 ms-2">
    이곳에도 마우스를 올려보세요
  </button>

  
  <script>
    const btn = document.querySelector('button')
    
    // 이벤트: 버튼 클릭 등의 사용자 동작
    // 이벤트 핸들러: 사용자가 특정 동작을 하면
    //      자동으로 등록된 함수를 실행
    const myFunc1 = function(event) {
      alert('버튼이 클릭됨!')
    }
    // 클릭 이벤트 발생 시 myFunc1 함수 호출
    // click: 사용자 동작명
    btn.addEventListener('click', myFunc1)


    const btns = document.querySelectorAll('button')    
    // 마우스를 올렸을 때(mouseover) 특정 함수 호출
    for(let i = 0; i < btns.length ; i++){
      btns[i].addEventListener('mouseover', (event) => {
        console.log(btns[i].innerHTML)
      })
    }

    // Array Helper Methods 를 활용하는 방법
    // 유사배열객체를 새로운 배열로 반환
    Array.from(btns).forEach((element) => {
      element.addEventListener('mouseover', (event) => {
        console.log(element.innerHTML)
      })
    })
  </script>
</body>
</html>
```

### 3. 요소 추가, 삭제해보기

- 버튼 클릭 시 `<p>` 태그 생성 및 삭제
  - `appendChild`: 특정 요소 아래 요소 추가
    - `document.body`: 최상위 객체인 document 하위의 body 태그

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<body>
  <button id="btn-create-p" class="btn btn-primary mt-2 ms-2">
    클릭하면 p 태그 생성
  </button>
  
  <script>
    // 요소 추가, 삭제해보기
    const btnCreatePTag = document.querySelector('#btn-create-p')
    btnCreatePTag.addEventListener('click', (event) => {
      const pTag = document.createElement('p')
      pTag.textContent = '생성된 p 태그'
      document.body.appendChild(pTag)

      // 버튼 클릭 시 요소 삭제
      const delButton = document.createElement('button')
      // Class 추가
      // 1. setAttribute
      // delButton.setAttribute('class', 'btn btn-danger')
      // 2. classList 에 add 쓰기
      delButton.classList.add('btn', 'btn-danger')
      delButton.textContent = '삭제'
      pTag.appendChild(delButton)
      delButton.addEventListener('click', (event) => {
        // 요소 삭제
        pTag.remove()
        delButton.remove()
      })
    })
  </script>
</body>
</html>
```

### 4. form 태그 활용하기

- 실습 3-5
- `event.preventDefault()`: 이벤트의 기본 동작을 막음
  - `<form>` 태그는 기본적으로 action 에 설정된 주소로 요청을 보냄.
  - 즉, 새로고침이 발생함
  - form 태그의 이벤트에 위 코드를 쓰면, 요청을 보내지 않도록 막아주는 기능을 해줌

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<body>
  <form id="myForm">
    <div>
      <input type="text" id="myInput">
      <input type="submit" value="Add">
    </div>
  </form>

  <ul id="output-list"></ul>

  
  <script>    
    const myForm = document.querySelector('#myForm')
    const myInput = document.querySelector('#myInput')
    const outputList = document.querySelector('#output-list')
    
    myForm.addEventListener('submit', (event) => {
      // 이벤트의 기본 동작을 막음
      // form 태그는 기본적으로 action = ""
      //  자기 자신 페이지를 다시 요청함(새로고침)
      event.preventDefault() // 새로고침을 막음
      
      // 사용자가 입력한 텍스트를 가져옴
      // const inputElement = document.querySelector('#myInput')

      // form 태그 안의 #myInput 을 선택
      // event.target: 이벤트가 발생하는 요소 정보
      // [권장사항] 특정 이벤트 요소의 내부에 있는 요소를 선택할 때
      const inputElement = event.target.querySelector('#myInput')
      const inputValue = inputElement.value
      if(inputValue == '') alert('값이 비어있다!')
      else {
        // ul 태그 자식으로 li 태그를 추가
        const newElement = document.createElement('li')
        newElement.textContent = inputValue
        outputList.appendChild(newElement)
        // 생성 후 input 영역을 빈 값으로 설정
        inputElement.value = ''
      }
    })
  </script>
</body>
</html>
```