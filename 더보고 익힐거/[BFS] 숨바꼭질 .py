from collections import deque
# 일단 데크(배열 완전체) 불러오고

n, k = map(int,input().split())

max_num =100000

visited = [0] * (max_num + 1)
# visted 판별이긴 한데 사실상 얘가 답이기도 함.
# 방문표시로서 값을 0에서 다른 값으로 바꿔줄건데 그때 답으로 바꿔주기때문. 답으로 계산한 적이 있으면 해당 항의 값이 0 이 아니게 되고
# 계산한적이 없으면(방문한적이 없으면) 건든게 없으니 0 임

def bfs():

    q = deque()  # 덱 만드는법
    q.append(n)  # 시작노드를 덱에 넣고 

    while q:   # 덱에 원소가 있는 동안 계속 반복. (빈덱 될때까지 계속 반복.)
        x = q.popleft()  # x는 방문할 노드임. 이때 노드는 breath next노드임. deep next가 아니라. 
                            # x는 덱에 남아있는 값들 중 가장 먼저 넣은 노드임. 즉 배열상 가장 앞에있는 값. append써서 뒤로넣고 pop써서 앞으로 뺀다.

        if x == k: # 만약 현재 방문한 노드가 목표지점이라면. 부연설명 : x 는 검사한 애들만 될 수 있음 덱에 들어갔다가 나온 값이기 때문에. 
            print(visited[k])
            break
        for j in (x-1, x+1, x*2):
            # 각 항의 딥다음노드 집합임. 이 부분이 문제마다 달라지는 것임. j는 연결노드 
            if 0 <= j <= max_num and not visited[j]:  # 딥다음노드가 계산하고자 하는 범위 안에 있고, 방문한적이 없을때(계산한 적이 없을때, visited[j]의 값이 0이 아닐때 )  
                visited[j] = visited[x] + 1 # 딥다음노드는 현재노드에 1을 더한다. (이 부분도 문제마다 달라지는 부분임.)
                q.append(j) # 딥다음노드를 덱에 추가한다.

bfs()


# BFS풀이 패턴 정리 
# 1. 준비물. 덱, 방문표시(정답표시)배열, 딥다음노드집합 파악
# 2. 덱에다가 시작 노드저장
# 3. 와일문 시작 
#       - 현재노드 정하기 , ( 덱에서 하나씩 꺼내와서 할당 )
#       - 만약에 현재노드가 목표지점이면 -> 출력 
#                - 여기서질문Q. 이경우(현재노드가 목표지점일때), 목표지점을 계산한 적이 있는지 없는지 따져줘야 하는거 아닌가요?
#                           A. 현재노드는 전부 덱에저장된적이 있던 노드이고, 덱에저장된 애들은 계산을 한 후에 저장하기 때문에(아래부분을 그렇게 짰음) 무조건 계산이 되어있는 애들임. 
#       - 딥다음노드들에 대하여 
#               계산한 적이 있으면 -> pass (??) 
#               계산한 적이 없으면 -> 현재 노드의 계산값에 뭔가 추가해서 저장해줌. (이 문제의 경우 1을 더해줌.)


# 헷갈리는 핵심.
# 자기차례가 되어서 자기 값을 계산하는게 아님 
# (자기차례가 되면 자기는 이미 딥이전노드에서 계산을 한적이 있고)
# 자기의 딥다음노드를 계산을 한다음에 덱에 추가하는거임.
